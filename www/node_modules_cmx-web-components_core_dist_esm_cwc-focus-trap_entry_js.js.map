{"version":3,"file":"node_modules_cmx-web-components_core_dist_esm_cwc-focus-trap_entry_js.js","mappings":";;;;;;;;;;;;;;;AAA0F;AACE;;AAE5F;AACA;AACA,QAAQ,oDAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAe,YAAY,iDAAQ,EAAE,iDAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAC,CAAC,gDAAI,QAAQ,oDAAC,UAAU,iCAAiC,GAAG,oDAAC,gBAAgB,oDAAC,UAAU,cAAc,GAAG,oDAAC,UAAU,+BAA+B;AACpK;AACA,iBAAiB,OAAO,oDAAU;AAClC,yBAAyB,UAAU,mCAAmC,kCAAkC,MAAM,qBAAqB;AACnI;;AAEuC;;;;;;;;;;;;;;;;;;;AChEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,0BAA0B;AACrC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAE8F","sources":["./node_modules/@cmx-web-components/core/dist/esm/cwc-focus-trap.entry.js","./node_modules/@cmx-web-components/core/dist/esm/index-eb5f436d.js"],"sourcesContent":["import { r as registerInstance, h, H as Host, g as getElement } from './core-cf426fab.js';\nimport { q as queryShadowRoot, b as isFocusable, i as isHidden } from './index-eb5f436d.js';\n\nconst FocusTrap = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        /**\n         * Activates the focus trap and focuses the first focusable element.\n         */\n        this.active = false;\n        /**\n         * Focuses the first focusable element in the focus trap.\n         */\n        this.focusFirstElement = () => {\n            this.trapFocus();\n        };\n        /**\n         * Focuses on either the last or first focusable element.\n         */\n        this.trapFocus = () => {\n            const focusableChildren = this.getFocusableElements();\n            if (focusableChildren.length > 0) {\n                focusableChildren[0].focus({ preventScroll: false });\n                this.backupElement.setAttribute('tabindex', '-1');\n            }\n            else {\n                // If there are no focusable children we need to focus on the backup\n                // to trap the focus. This is a useful behavior if the focus trap is\n                // for example used in a dialog and we don't want the user to tab\n                // outside the dialog even though there are no focusable children\n                // in the dialog.\n                this.backupElement.setAttribute('tabindex', '0');\n                this.backupElement.focus();\n            }\n        };\n    }\n    /**\n     * Returns a list of the focusable children found within the element.\n     */\n    getFocusableElements() {\n        return queryShadowRoot(this.host, isHidden, isFocusable);\n    }\n    componentDidLoad() {\n        this.backupElement = this.host.shadowRoot.querySelector('#backup');\n        this.startElement = this.host.shadowRoot.querySelector('#start');\n        this.endElement = this.host.shadowRoot.querySelector('#end');\n        this.startElement.addEventListener('focus', this.focusFirstElement);\n        this.endElement.addEventListener('focus', this.focusFirstElement);\n    }\n    componentDidUpdate() {\n        this.active && this.startElement.focus();\n    }\n    disconnectedCallback() {\n        this.startElement && this.startElement.removeEventListener('focus', this.focusFirstElement);\n        this.endElement && this.endElement.removeEventListener('focus', this.focusFirstElement);\n    }\n    render() {\n        const tabindex = this.active ? '0' : '-1';\n        return (h(Host, null, h(\"div\", { id: \"start\", tabindex: tabindex }), h(\"slot\", null), h(\"div\", { id: \"backup\" }), h(\"div\", { id: \"end\", tabindex: tabindex })));\n    }\n    get host() { return getElement(this); }\n    static get style() { return \"*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:inline-block}\"; }\n};\n\nexport { FocusTrap as cwc_focus_trap };\n","/**\r\n * Returns whether the element is hidden.\r\n * @param elem\r\n */\r\nfunction isHidden(elem) {\r\n    return (elem.hasAttribute('hidden') ||\r\n        (elem.hasAttribute('aria-hidden') && elem.getAttribute('aria-hidden') !== 'false') ||\r\n        // A quick and dirty way to check whether the element is hidden.\r\n        // For a more fine-grained check we could use \"window.getComputedStyle\" but we don't because of bad performance.\r\n        // If the element has visibility set to \"hidden\" or \"collapse\", display set to \"none\" or opacity set to \"0\" through CSS\r\n        // we won't be able to catch it here. We accept it due to the huge performance benefits.\r\n        elem.style.display === `none` ||\r\n        elem.style.opacity === `0` ||\r\n        elem.style.visibility === `hidden` ||\r\n        elem.style.visibility === `collapse`);\r\n}\r\n/**\r\n * Returns whether the element is disabled.\r\n * @param elem\r\n */\r\nfunction isDisabled(elem) {\r\n    return (elem.hasAttribute('disabled') ||\r\n        (elem.hasAttribute('aria-disabled') && elem.getAttribute('aria-disabled') !== 'false'));\r\n}\r\n/**\r\n * Determines whether an element is focusable.\r\n * Read more here: https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus/1600194#1600194\r\n * Or here: https://stackoverflow.com/questions/18261595/how-to-check-if-a-dom-element-is-focusable\r\n * @param elem\r\n */\r\nfunction isFocusable(elem) {\r\n    // Discard elements that are removed from the tab order.\r\n    if (elem.getAttribute('tabindex') === '-1' || isHidden(elem) || isDisabled(elem)) {\r\n        return false;\r\n    }\r\n    return (\r\n    // At this point we know that the element can have focus (eg. won't be -1) if the tabindex attribute exists\r\n    elem.hasAttribute('tabindex') ||\r\n        // Anchor tags or area tags with a href set\r\n        ((elem instanceof HTMLAnchorElement || elem instanceof HTMLAreaElement) && elem.hasAttribute('href')) ||\r\n        // Form elements which are not disabled\r\n        (elem instanceof HTMLButtonElement ||\r\n            elem instanceof HTMLInputElement ||\r\n            elem instanceof HTMLTextAreaElement ||\r\n            elem instanceof HTMLSelectElement) ||\r\n        // IFrames\r\n        elem instanceof HTMLIFrameElement);\r\n}\n\n/**\r\n * Traverses the slots of the open shadowroots and returns all children matching the query.\r\n * @param {ShadowRoot | HTMLElement} root\r\n * @param skipNode\r\n * @param isMatch\r\n * @param {number} maxDepth\r\n * @param {number} depth\r\n * @returns {HTMLElement[]}\r\n */\r\nfunction queryShadowRoot(root, skipNode, isMatch, maxDepth = 20, depth = 0) {\r\n    let matches = [];\r\n    // If the depth is above the max depth, abort the searching here.\r\n    if (depth >= maxDepth) {\r\n        return matches;\r\n    }\r\n    // Traverses a slot element\r\n    const traverseSlot = (slot) => {\r\n        // Only check nodes that are of the type Node.ELEMENT_NODE\r\n        // Read more here https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\r\n        const assignedNodes = slot.assignedNodes().filter(node => node.nodeType === 1);\r\n        if (assignedNodes.length > 0) {\r\n            return queryShadowRoot(assignedNodes[0].parentElement, skipNode, isMatch, maxDepth, depth + 1);\r\n        }\r\n        return [];\r\n    };\r\n    // Go through each child and continue the traversing if necessary\r\n    // Even though the typing says that children can't be undefined, Edge 15 sometimes gives an undefined value.\r\n    // Therefore we fallback to an empty array if it is undefined.\r\n    const children = Array.from(root.children || []);\r\n    for (const child of children) {\r\n        // Check if the node and its descendants should be skipped\r\n        if (skipNode(child)) {\r\n            continue;\r\n        }\r\n        // If the child matches we always add it\r\n        if (isMatch(child)) {\r\n            matches.push(child);\r\n        }\r\n        if (child.shadowRoot != null) {\r\n            matches.push(...queryShadowRoot(child.shadowRoot, skipNode, isMatch, maxDepth, depth + 1));\r\n        }\r\n        else if (child.tagName === 'SLOT') {\r\n            matches.push(...traverseSlot(child));\r\n        }\r\n        else {\r\n            matches.push(...queryShadowRoot(child, skipNode, isMatch, maxDepth, depth + 1));\r\n        }\r\n    }\r\n    return matches;\r\n}\n\nconst tuple = (...args) => args;\n\nexport { isDisabled as a, isFocusable as b, isHidden as i, queryShadowRoot as q, tuple as t };\n"],"names":[],"sourceRoot":"webpack:///"}