{"version":3,"file":"node_modules_cmx-web-components_core_dist_esm_cwc-table-sort-label_entry_js.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;;;;;AC3C4C;AAC9D;AACgC;AAC+B;;AAE5F;AACA;AACA,QAAQ,oDAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAiB;AACjD;AACA;AACA,0BAA0B,iDAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAW;AACpC;AACA;AACA;AACA,gCAAgC,2DAA2B;AAC3D;AACA;AACA;AACA,QAAQ,uEAAU;AAClB;AACA;AACA,QAAQ,uEAAa;AACrB;AACA;AACA,4BAA4B,2DAA2B;AACvD;AACA;AACA,sBAAsB,iDAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAC,CAAC,gDAAI,IAAI,4IAA4I,EAAE,oDAAC,gBAAgB,oDAAC,eAAe,+EAA+E;AACxR;AACA,4BAA4B;AAC5B;AACA;AACA,yBAAyB,UAAU,mCAAmC,kCAAkC,MAAM,eAAe,+BAA+B,kBAAkB,SAAS,kBAAkB,sBAAsB;AAC/N;;AAEkD;;;;;;;;;;;;;;;;;;;AC1ElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,0BAA0B;AACrC;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAE8F;;;;;;;;;;;;;;;;ACtG7C;;AAEjD,0BAA0B,qDAAK;;AAEG","sources":["./node_modules/@cmx-web-components/core/dist/esm/commonComponentFeatures-b771e888.js","./node_modules/@cmx-web-components/core/dist/esm/cwc-table-sort-label.entry.js","./node_modules/@cmx-web-components/core/dist/esm/index-eb5f436d.js","./node_modules/@cmx-web-components/core/dist/esm/types-56dd385d.js"],"sourcesContent":["function InitializeDirectionDetection(hostElement) {\r\n    // the function that sets the dir in the shadow dom\r\n    function executeDir(dir) {\r\n        const shadowKids = hostElement.shadowRoot.childNodes;\r\n        shadowKids.forEach(element => {\r\n            element.setAttribute('dir', dir);\r\n        });\r\n    }\r\n    function intervalHandler() {\r\n        const actualDir = hostElement.dataset.dir;\r\n        const dir = window.getComputedStyle(hostElement).getPropertyValue('direction');\r\n        if (dir !== actualDir) {\r\n            hostElement.dataset.dir = dir;\r\n            hostElement.shadowRoot && executeDir(dir);\r\n            if (dir === 'rtl') {\r\n                return hostElement.setAttribute('rtl', 'true');\r\n            }\r\n            return hostElement.removeAttribute('rtl');\r\n        }\r\n    }\r\n    hostElement['rtlInterval'] = setInterval(intervalHandler, 750);\r\n}\r\nfunction DestroyDirectionDetection(hostElement) {\r\n    if (hostElement && hostElement['rtlInterval']) {\r\n        clearInterval(hostElement['rtlInterval']);\r\n    }\r\n}\n\nfunction setDesignVersion() {\r\n    const frameworkVersion = getComputedStyle(document.documentElement).getPropertyValue('--cwc-version');\r\n    return frameworkVersion ? frameworkVersion : 'v1';\r\n}\n\nfunction initBasics(componentClass) {\r\n    !componentClass.designVersion && (componentClass.designVersion = setDesignVersion());\r\n    if (!componentClass.rtl) {\r\n        componentClass.host && InitializeDirectionDetection(componentClass.host);\r\n    }\r\n}\r\nfunction destroyBasics(componentClass) {\r\n    DestroyDirectionDetection(componentClass.host);\r\n}\n\nexport { destroyBasics as d, initBasics as i };\n","import { r as registerInstance, c as createEvent, h, H as Host } from './core-cf426fab.js';\nimport './index-eb5f436d.js';\nimport { c as cwcTableSortOrder } from './types-56dd385d.js';\nimport { i as initBasics, d as destroyBasics } from './commonComponentFeatures-b771e888.js';\n\nconst TableSortLabel = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        /**\n         * The design version of the framework\n         */\n        this.designVersion = null;\n        /**\n         * Sets corresponding sort order icon.\n         */\n        this.order = 'none';\n        /**\n         * Specify whether component should render from right to left\n         */\n        this.rtl = false;\n        /**\n         * How many times user clicked on the component.\n         */\n        this.clickedTimes = 0;\n        this.handleClick = () => {\n            this.clickedTimes++;\n            if (this.clickedTimes > 2) {\n                this.clickedTimes = 0;\n            }\n            this.cwcChange.emit(cwcTableSortOrder[this.clickedTimes]);\n        };\n        this.getAriaSort = () => {\n            const order = cwcTableSortOrder[this.clickedTimes];\n            const orderToAriaSort = new Map([\n                ['none', 'none'],\n                ['asc', 'ascending'],\n                ['desc', 'descending'],\n            ]);\n            return orderToAriaSort.get(order) || 'other';\n        };\n        this.cwcChange = createEvent(this, \"cwcChange\", 7);\n    }\n    setOrder(newValue, oldValue) {\n        if (oldValue !== newValue) {\n            this.clickedTimes = cwcTableSortOrder.findIndex(element => element === newValue);\n        }\n    }\n    componentWillLoad() {\n        initBasics(this);\n    }\n    disconnectedCallback() {\n        destroyBasics(this);\n    }\n    componentDidLoad() {\n        this.clickedTimes = cwcTableSortOrder.findIndex(element => element === this.order);\n    }\n    getIcon() {\n        const order = cwcTableSortOrder[this.clickedTimes];\n        const icons = {\n            none: 'sort-idle',\n            asc: 'sort-up',\n            desc: 'sort-down',\n        };\n        return icons[order];\n    }\n    render() {\n        return (h(Host, { onClick: this.handleClick, role: \"columnheader\", \"aria-sort\": this.getAriaSort(), dir: this.rtl ? 'rtl' : 'ltr', class: this.designVersion }, h(\"slot\", null), h(\"cwc-icon\", { designVersion: this.designVersion, name: this.getIcon(), color: \"bright-blue\" })));\n    }\n    static get watchers() { return {\n        \"order\": [\"setOrder\"]\n    }; }\n    static get style() { return \"*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{cursor:pointer}:host([data-dir=rtl]) cwc-icon{padding:0 2px 0 0}cwc-icon{padding:0 0 0 2px;vertical-align:middle}\"; }\n};\n\nexport { TableSortLabel as cwc_table_sort_label };\n","/**\r\n * Returns whether the element is hidden.\r\n * @param elem\r\n */\r\nfunction isHidden(elem) {\r\n    return (elem.hasAttribute('hidden') ||\r\n        (elem.hasAttribute('aria-hidden') && elem.getAttribute('aria-hidden') !== 'false') ||\r\n        // A quick and dirty way to check whether the element is hidden.\r\n        // For a more fine-grained check we could use \"window.getComputedStyle\" but we don't because of bad performance.\r\n        // If the element has visibility set to \"hidden\" or \"collapse\", display set to \"none\" or opacity set to \"0\" through CSS\r\n        // we won't be able to catch it here. We accept it due to the huge performance benefits.\r\n        elem.style.display === `none` ||\r\n        elem.style.opacity === `0` ||\r\n        elem.style.visibility === `hidden` ||\r\n        elem.style.visibility === `collapse`);\r\n}\r\n/**\r\n * Returns whether the element is disabled.\r\n * @param elem\r\n */\r\nfunction isDisabled(elem) {\r\n    return (elem.hasAttribute('disabled') ||\r\n        (elem.hasAttribute('aria-disabled') && elem.getAttribute('aria-disabled') !== 'false'));\r\n}\r\n/**\r\n * Determines whether an element is focusable.\r\n * Read more here: https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus/1600194#1600194\r\n * Or here: https://stackoverflow.com/questions/18261595/how-to-check-if-a-dom-element-is-focusable\r\n * @param elem\r\n */\r\nfunction isFocusable(elem) {\r\n    // Discard elements that are removed from the tab order.\r\n    if (elem.getAttribute('tabindex') === '-1' || isHidden(elem) || isDisabled(elem)) {\r\n        return false;\r\n    }\r\n    return (\r\n    // At this point we know that the element can have focus (eg. won't be -1) if the tabindex attribute exists\r\n    elem.hasAttribute('tabindex') ||\r\n        // Anchor tags or area tags with a href set\r\n        ((elem instanceof HTMLAnchorElement || elem instanceof HTMLAreaElement) && elem.hasAttribute('href')) ||\r\n        // Form elements which are not disabled\r\n        (elem instanceof HTMLButtonElement ||\r\n            elem instanceof HTMLInputElement ||\r\n            elem instanceof HTMLTextAreaElement ||\r\n            elem instanceof HTMLSelectElement) ||\r\n        // IFrames\r\n        elem instanceof HTMLIFrameElement);\r\n}\n\n/**\r\n * Traverses the slots of the open shadowroots and returns all children matching the query.\r\n * @param {ShadowRoot | HTMLElement} root\r\n * @param skipNode\r\n * @param isMatch\r\n * @param {number} maxDepth\r\n * @param {number} depth\r\n * @returns {HTMLElement[]}\r\n */\r\nfunction queryShadowRoot(root, skipNode, isMatch, maxDepth = 20, depth = 0) {\r\n    let matches = [];\r\n    // If the depth is above the max depth, abort the searching here.\r\n    if (depth >= maxDepth) {\r\n        return matches;\r\n    }\r\n    // Traverses a slot element\r\n    const traverseSlot = (slot) => {\r\n        // Only check nodes that are of the type Node.ELEMENT_NODE\r\n        // Read more here https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\r\n        const assignedNodes = slot.assignedNodes().filter(node => node.nodeType === 1);\r\n        if (assignedNodes.length > 0) {\r\n            return queryShadowRoot(assignedNodes[0].parentElement, skipNode, isMatch, maxDepth, depth + 1);\r\n        }\r\n        return [];\r\n    };\r\n    // Go through each child and continue the traversing if necessary\r\n    // Even though the typing says that children can't be undefined, Edge 15 sometimes gives an undefined value.\r\n    // Therefore we fallback to an empty array if it is undefined.\r\n    const children = Array.from(root.children || []);\r\n    for (const child of children) {\r\n        // Check if the node and its descendants should be skipped\r\n        if (skipNode(child)) {\r\n            continue;\r\n        }\r\n        // If the child matches we always add it\r\n        if (isMatch(child)) {\r\n            matches.push(child);\r\n        }\r\n        if (child.shadowRoot != null) {\r\n            matches.push(...queryShadowRoot(child.shadowRoot, skipNode, isMatch, maxDepth, depth + 1));\r\n        }\r\n        else if (child.tagName === 'SLOT') {\r\n            matches.push(...traverseSlot(child));\r\n        }\r\n        else {\r\n            matches.push(...queryShadowRoot(child, skipNode, isMatch, maxDepth, depth + 1));\r\n        }\r\n    }\r\n    return matches;\r\n}\n\nconst tuple = (...args) => args;\n\nexport { isDisabled as a, isFocusable as b, isHidden as i, queryShadowRoot as q, tuple as t };\n","import { t as tuple } from './index-eb5f436d.js';\n\nconst cwcTableSortOrder = tuple('none', 'asc', 'desc');\n\nexport { cwcTableSortOrder as c };\n"],"names":[],"sourceRoot":"webpack:///"}