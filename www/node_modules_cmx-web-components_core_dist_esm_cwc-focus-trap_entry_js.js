"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_cmx-web-components_core_dist_esm_cwc-focus-trap_entry_js"],{

/***/ 92390:
/*!********************************************************************************!*\
  !*** ./node_modules/@cmx-web-components/core/dist/esm/cwc-focus-trap.entry.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cwc_focus_trap": () => (/* binding */ FocusTrap)
/* harmony export */ });
/* harmony import */ var _core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-cf426fab.js */ 98545);
/* harmony import */ var _index_eb5f436d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-eb5f436d.js */ 12361);



const FocusTrap = class {
    constructor(hostRef) {
        (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        /**
         * Activates the focus trap and focuses the first focusable element.
         */
        this.active = false;
        /**
         * Focuses the first focusable element in the focus trap.
         */
        this.focusFirstElement = () => {
            this.trapFocus();
        };
        /**
         * Focuses on either the last or first focusable element.
         */
        this.trapFocus = () => {
            const focusableChildren = this.getFocusableElements();
            if (focusableChildren.length > 0) {
                focusableChildren[0].focus({ preventScroll: false });
                this.backupElement.setAttribute('tabindex', '-1');
            }
            else {
                // If there are no focusable children we need to focus on the backup
                // to trap the focus. This is a useful behavior if the focus trap is
                // for example used in a dialog and we don't want the user to tab
                // outside the dialog even though there are no focusable children
                // in the dialog.
                this.backupElement.setAttribute('tabindex', '0');
                this.backupElement.focus();
            }
        };
    }
    /**
     * Returns a list of the focusable children found within the element.
     */
    getFocusableElements() {
        return (0,_index_eb5f436d_js__WEBPACK_IMPORTED_MODULE_1__.q)(this.host, _index_eb5f436d_js__WEBPACK_IMPORTED_MODULE_1__.i, _index_eb5f436d_js__WEBPACK_IMPORTED_MODULE_1__.b);
    }
    componentDidLoad() {
        this.backupElement = this.host.shadowRoot.querySelector('#backup');
        this.startElement = this.host.shadowRoot.querySelector('#start');
        this.endElement = this.host.shadowRoot.querySelector('#end');
        this.startElement.addEventListener('focus', this.focusFirstElement);
        this.endElement.addEventListener('focus', this.focusFirstElement);
    }
    componentDidUpdate() {
        this.active && this.startElement.focus();
    }
    disconnectedCallback() {
        this.startElement && this.startElement.removeEventListener('focus', this.focusFirstElement);
        this.endElement && this.endElement.removeEventListener('focus', this.focusFirstElement);
    }
    render() {
        const tabindex = this.active ? '0' : '-1';
        return ((0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)(_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.H, null, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { id: "start", tabindex: tabindex }), (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null), (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { id: "backup" }), (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { id: "end", tabindex: tabindex })));
    }
    get host() { return (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
    static get style() { return "*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:inline-block}"; }
};




/***/ }),

/***/ 12361:
/*!**************************************************************************!*\
  !*** ./node_modules/@cmx-web-components/core/dist/esm/index-eb5f436d.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ isDisabled),
/* harmony export */   "b": () => (/* binding */ isFocusable),
/* harmony export */   "i": () => (/* binding */ isHidden),
/* harmony export */   "q": () => (/* binding */ queryShadowRoot),
/* harmony export */   "t": () => (/* binding */ tuple)
/* harmony export */ });
/**
 * Returns whether the element is hidden.
 * @param elem
 */
function isHidden(elem) {
    return (elem.hasAttribute('hidden') ||
        (elem.hasAttribute('aria-hidden') && elem.getAttribute('aria-hidden') !== 'false') ||
        // A quick and dirty way to check whether the element is hidden.
        // For a more fine-grained check we could use "window.getComputedStyle" but we don't because of bad performance.
        // If the element has visibility set to "hidden" or "collapse", display set to "none" or opacity set to "0" through CSS
        // we won't be able to catch it here. We accept it due to the huge performance benefits.
        elem.style.display === `none` ||
        elem.style.opacity === `0` ||
        elem.style.visibility === `hidden` ||
        elem.style.visibility === `collapse`);
}
/**
 * Returns whether the element is disabled.
 * @param elem
 */
function isDisabled(elem) {
    return (elem.hasAttribute('disabled') ||
        (elem.hasAttribute('aria-disabled') && elem.getAttribute('aria-disabled') !== 'false'));
}
/**
 * Determines whether an element is focusable.
 * Read more here: https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus/1600194#1600194
 * Or here: https://stackoverflow.com/questions/18261595/how-to-check-if-a-dom-element-is-focusable
 * @param elem
 */
function isFocusable(elem) {
    // Discard elements that are removed from the tab order.
    if (elem.getAttribute('tabindex') === '-1' || isHidden(elem) || isDisabled(elem)) {
        return false;
    }
    return (
    // At this point we know that the element can have focus (eg. won't be -1) if the tabindex attribute exists
    elem.hasAttribute('tabindex') ||
        // Anchor tags or area tags with a href set
        ((elem instanceof HTMLAnchorElement || elem instanceof HTMLAreaElement) && elem.hasAttribute('href')) ||
        // Form elements which are not disabled
        (elem instanceof HTMLButtonElement ||
            elem instanceof HTMLInputElement ||
            elem instanceof HTMLTextAreaElement ||
            elem instanceof HTMLSelectElement) ||
        // IFrames
        elem instanceof HTMLIFrameElement);
}

/**
 * Traverses the slots of the open shadowroots and returns all children matching the query.
 * @param {ShadowRoot | HTMLElement} root
 * @param skipNode
 * @param isMatch
 * @param {number} maxDepth
 * @param {number} depth
 * @returns {HTMLElement[]}
 */
function queryShadowRoot(root, skipNode, isMatch, maxDepth = 20, depth = 0) {
    let matches = [];
    // If the depth is above the max depth, abort the searching here.
    if (depth >= maxDepth) {
        return matches;
    }
    // Traverses a slot element
    const traverseSlot = (slot) => {
        // Only check nodes that are of the type Node.ELEMENT_NODE
        // Read more here https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
        const assignedNodes = slot.assignedNodes().filter(node => node.nodeType === 1);
        if (assignedNodes.length > 0) {
            return queryShadowRoot(assignedNodes[0].parentElement, skipNode, isMatch, maxDepth, depth + 1);
        }
        return [];
    };
    // Go through each child and continue the traversing if necessary
    // Even though the typing says that children can't be undefined, Edge 15 sometimes gives an undefined value.
    // Therefore we fallback to an empty array if it is undefined.
    const children = Array.from(root.children || []);
    for (const child of children) {
        // Check if the node and its descendants should be skipped
        if (skipNode(child)) {
            continue;
        }
        // If the child matches we always add it
        if (isMatch(child)) {
            matches.push(child);
        }
        if (child.shadowRoot != null) {
            matches.push(...queryShadowRoot(child.shadowRoot, skipNode, isMatch, maxDepth, depth + 1));
        }
        else if (child.tagName === 'SLOT') {
            matches.push(...traverseSlot(child));
        }
        else {
            matches.push(...queryShadowRoot(child, skipNode, isMatch, maxDepth, depth + 1));
        }
    }
    return matches;
}

const tuple = (...args) => args;




/***/ })

}]);
//# sourceMappingURL=node_modules_cmx-web-components_core_dist_esm_cwc-focus-trap_entry_js.js.map