"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_cmx-web-components_core_dist_esm_cwc-tooltip_entry_js"],{

/***/ 27345:
/*!********************************************************************************************!*\
  !*** ./node_modules/@cmx-web-components/core/dist/esm/commonComponentFeatures-b771e888.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": () => (/* binding */ destroyBasics),
/* harmony export */   "i": () => (/* binding */ initBasics)
/* harmony export */ });
function InitializeDirectionDetection(hostElement) {
    // the function that sets the dir in the shadow dom
    function executeDir(dir) {
        const shadowKids = hostElement.shadowRoot.childNodes;
        shadowKids.forEach(element => {
            element.setAttribute('dir', dir);
        });
    }
    function intervalHandler() {
        const actualDir = hostElement.dataset.dir;
        const dir = window.getComputedStyle(hostElement).getPropertyValue('direction');
        if (dir !== actualDir) {
            hostElement.dataset.dir = dir;
            hostElement.shadowRoot && executeDir(dir);
            if (dir === 'rtl') {
                return hostElement.setAttribute('rtl', 'true');
            }
            return hostElement.removeAttribute('rtl');
        }
    }
    hostElement['rtlInterval'] = setInterval(intervalHandler, 750);
}
function DestroyDirectionDetection(hostElement) {
    if (hostElement && hostElement['rtlInterval']) {
        clearInterval(hostElement['rtlInterval']);
    }
}

function setDesignVersion() {
    const frameworkVersion = getComputedStyle(document.documentElement).getPropertyValue('--cwc-version');
    return frameworkVersion ? frameworkVersion : 'v1';
}

function initBasics(componentClass) {
    !componentClass.designVersion && (componentClass.designVersion = setDesignVersion());
    if (!componentClass.rtl) {
        componentClass.host && InitializeDirectionDetection(componentClass.host);
    }
}
function destroyBasics(componentClass) {
    DestroyDirectionDetection(componentClass.host);
}




/***/ }),

/***/ 57399:
/*!*****************************************************************************!*\
  !*** ./node_modules/@cmx-web-components/core/dist/esm/cwc-tooltip.entry.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cwc_tooltip": () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-cf426fab.js */ 98545);
/* harmony import */ var _commonComponentFeatures_b771e888_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./commonComponentFeatures-b771e888.js */ 27345);



const Tooltip = class {
    constructor(hostRef) {
        (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
        this.hidden = true;
        this.layerStyle = {};
        this.orientation = 'top';
        /**
         * The design version of the framework
         */
        this.designVersion = null;
        /**
         * disables the tooltip funcitonality
         */
        this.disabled = false;
        /**
         * Specify whether component should render from right to left
         */
        this.rtl = false;
        /**
         * Specify whether component should render as block or inline element
         */
        this.block = false;
        // this funciton shows the tooltip
        this.showTooltip = () => {
            if (!this.disabled) {
                setTimeout(() => {
                    document.addEventListener('scroll', this.hideTooltip, true);
                    document.addEventListener('cwcScroll', this.hideTooltip, true);
                    window.addEventListener('resize', this.hideTooltip);
                });
                this.positionTooltip();
                this.layerStyle = Object.assign({}, this.layerStyle);
                this.hidden = false;
                this.layer.classList.add('fadeout');
                this.layer.classList.remove('cwc-hidden');
            }
        };
        // this funciton hides the tooltip
        this.hideTooltip = () => {
            this.hidden = true;
            document.removeEventListener('scroll', this.hideTooltip, true);
            document.removeEventListener('cwcScroll', this.hideTooltip, true);
            window.removeEventListener('resize', this.hideTooltip);
            this.layer.classList.remove('fadeout');
            this.layer.classList.add('cwc-hidden');
        };
        this.positionTooltip = () => {
            // find position on screen
            const elementDimensions = this.targetElement.getBoundingClientRect();
            // get tooltip dimensions
            const layerDimensions = this.layer.getBoundingClientRect();
            // get window width
            const windowDimensions = {
                width: document.documentElement.clientWidth,
            };
            // define base tooltip style
            const layerStyle = {
                left: '',
                top: '',
            };
            let caseString;
            let sideValue;
            sideValue = elementDimensions.left + layerDimensions.width / 2;
            // define the overflow scenario for a particular class and the positioning switch
            if (elementDimensions.top > layerDimensions.height &&
                elementDimensions.left > layerDimensions.width / 2 &&
                windowDimensions.width > sideValue) {
                caseString = 'top';
            }
            if (elementDimensions.top < layerDimensions.height &&
                elementDimensions.left > layerDimensions.width / 2 &&
                windowDimensions.width > sideValue) {
                caseString = 'bottom';
            }
            if (elementDimensions.left < layerDimensions.width / 2) {
                caseString = 'right';
            }
            if (windowDimensions.width < sideValue) {
                caseString = 'left';
            }
            // get the top left values with the orientation string
            const topleft = this.getOrientation(`${caseString}`, elementDimensions, layerDimensions);
            // assign the new layer style
            const fullStyle = Object.assign(Object.assign({}, layerStyle), topleft);
            this.setLayerStyle(fullStyle);
            // assign the orientation for custom orientation classes
            this.setOrientation(caseString);
        };
        this.setOrientation = orientation => {
            this.orientation = orientation;
            this.layer.classList.remove('top', 'bottom', 'left', 'right');
            this.layer.classList.add(orientation);
        };
        this.setLayerStyle = layerStyles => {
            const fullStyle = Object.assign({}, layerStyles);
            Object.keys(fullStyle).forEach(style => {
                this.layer.style[style] = fullStyle[style];
            });
        };
    }
    setWidth(newValue, oldValue) {
        if (oldValue !== newValue) {
            this.width = newValue;
        }
    }
    setHeight(newValue, oldValue) {
        if (oldValue !== newValue) {
            this.height = newValue;
        }
    }
    setContent(newValue) {
        document.getElementById(this.tooltipId).innerHTML = newValue;
    }
    getOrientation(key, elementDimensions, layerDimensions) {
        const formulas = new Map();
        formulas.set('top', {
            left: elementDimensions.left + (elementDimensions.width - layerDimensions.width) / 2 + 'px',
            top: elementDimensions.top - layerDimensions.height - 8 + 'px',
        });
        formulas.set('bottom', {
            left: elementDimensions.left + elementDimensions.width / 2 - layerDimensions.width / 2 + 'px',
            top: elementDimensions.top + elementDimensions.height + 2 + 'px',
        });
        formulas.set('left', {
            left: elementDimensions.left - layerDimensions.width - 6 + 'px',
            top: elementDimensions.top + elementDimensions.height / 2 - layerDimensions.height / 2 + 'px',
        });
        formulas.set('right', {
            left: elementDimensions.left + elementDimensions.width + 6 + 'px',
            top: elementDimensions.top + elementDimensions.height / 2 - layerDimensions.height / 2 + 'px',
        });
        return formulas.get(key);
    }
    componentWillLoad() {
        (0,_commonComponentFeatures_b771e888_js__WEBPACK_IMPORTED_MODULE_1__.i)(this);
    }
    componentDidLoad() {
        // we are creating the tooltip the old DOM manipulation way to be able to render it as the last element
        // of the page, so that we can position it over any element of the DOM
        const destination = document.createElement('div');
        // store layer ref for later manipulation
        this.layer = destination;
        // set layer attributes
        destination.setAttribute('role', 'dialog');
        this.ariaLabel && destination.setAttribute('aria-label', this.ariaLabel);
        destination.setAttribute('aria-modal', 'true');
        // give it unique id
        this.tooltipId =
            'tooltip_' +
                Math.random()
                    .toString(36)
                    .substr(2, 9);
        destination.setAttribute('id', this.tooltipId);
        // set the proper class
        destination.classList.add('cwc-tooltip', this.designVersion, 'fadeout', this.hidden ? 'cwc-hidden' : '', this.orientation);
        // set content
        if (this.content) {
            destination.innerHTML = this.content;
        }
        else {
            destination.appendChild(this.contentElement);
        }
        // append it to the body
        document.querySelector('body').appendChild(destination);
        (0,_commonComponentFeatures_b771e888_js__WEBPACK_IMPORTED_MODULE_1__.i)(this);
    }
    disconnectedCallback() {
        this.layer.parentNode.removeChild(this.layer);
        (0,_commonComponentFeatures_b771e888_js__WEBPACK_IMPORTED_MODULE_1__.d)(this);
    }
    render() {
        return ((0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)(_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.H, { class: `${this.designVersion} ${this.block && 'block'}` }, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: el => (this.targetElement = el), class: 'cwc-tooltip__target' + (this.disabled ? ' disabled' : ''), style: { display: this.block ? 'block' : 'inline-block' }, onMouseEnter: this.showTooltip, onMouseLeave: this.hideTooltip }, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", null)), (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", { ref: el => (this.contentElement = el) }, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.h)("slot", { name: "content" }))));
    }
    get host() { return (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }
    static get watchers() { return {
        "width": ["setWidth"],
        "height": ["setHeight"],
        "content": ["setContent"]
    }; }
    static get style() { return "*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}cwc-tooltip{display:inline-block}cwc-tooltip.block{display:block}.cwc-tooltip{display:table;max-width:25vw;border:1px solid var(--cwc-tooltip-border-color,var(--cwc-color-grayscale-dark,#333));border-radius:3px;color:var(--cwc-tooltip-color,var(--cwc-color-grayscale-lightest,#e4e4e4));font-size:.75rem;line-height:.875rem;background:var(--cwc-tooltip-background-color,var(--cwc-color-grayscale-dark,#333));padding:.5rem 1rem;position:fixed;font-weight:500;text-align:center;z-index:999;pointer-events:none}.cwc-tooltip__target,.cwc-tooltip__target>slot{display:inline-block}.cwc-tooltip.cwc-hidden{opacity:0}.cwc-tooltip:before{content:\"\";position:absolute;width:0;height:0;margin-left:-9px;bottom:-13px;left:50%;-webkit-box-sizing:border-box;box-sizing:border-box;border:6px solid #000;border-color:transparent transparent var(--cwc-color-grayscale-dark,#333) var(--cwc-color-grayscale-dark,#333);-webkit-transform-origin:0 0;transform-origin:0 0;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.cwc-tooltip.bottom:before{border-color:var(--cwc-color-grayscale-dark,#333) var(--cwc-color-grayscale-dark,#333) transparent transparent;bottom:auto;top:0}.cwc-tooltip.right:before{border-color:var(--cwc-color-grayscale-dark,#333) transparent transparent var(--cwc-color-grayscale-dark,#333);bottom:auto;left:1px;top:50%}.cwc-tooltip.left:before{border-color:transparent var(--cwc-color-grayscale-dark,#333) var(--cwc-color-grayscale-dark,#333) transparent;bottom:auto;right:-4px;top:50%;left:auto}.cwc-tooltip:not(.cwc-hidden){-webkit-animation:fadein .15s;animation:fadein .15s}.cwc-tooltip:not(.fadeout){-webkit-animation:fadeout .15s;animation:fadeout .15s}\@-webkit-keyframes fadein{0%{opacity:0}to{opacity:1}}\@keyframes fadein{0%{opacity:0}to{opacity:1}}\@-webkit-keyframes fadeout{0%{opacity:1}to{opacity:0}}\@keyframes fadeout{0%{opacity:1}to{opacity:0}}\@media (max-width:767px){.cwc-tooltip{max-width:50vw}}"; }
};




/***/ })

}]);
//# sourceMappingURL=node_modules_cmx-web-components_core_dist_esm_cwc-tooltip_entry_js.js.map