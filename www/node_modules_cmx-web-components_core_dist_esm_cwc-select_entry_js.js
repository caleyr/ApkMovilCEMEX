"use strict";
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["node_modules_cmx-web-components_core_dist_esm_cwc-select_entry_js"],{

/***/ 27345:
/*!********************************************************************************************!*\
  !*** ./node_modules/@cmx-web-components/core/dist/esm/commonComponentFeatures-b771e888.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": () => (/* binding */ destroyBasics),
/* harmony export */   "i": () => (/* binding */ initBasics)
/* harmony export */ });
function InitializeDirectionDetection(hostElement) {
    // the function that sets the dir in the shadow dom
    function executeDir(dir) {
        const shadowKids = hostElement.shadowRoot.childNodes;
        shadowKids.forEach(element => {
            element.setAttribute('dir', dir);
        });
    }
    function intervalHandler() {
        const actualDir = hostElement.dataset.dir;
        const dir = window.getComputedStyle(hostElement).getPropertyValue('direction');
        if (dir !== actualDir) {
            hostElement.dataset.dir = dir;
            hostElement.shadowRoot && executeDir(dir);
            if (dir === 'rtl') {
                return hostElement.setAttribute('rtl', 'true');
            }
            return hostElement.removeAttribute('rtl');
        }
    }
    hostElement['rtlInterval'] = setInterval(intervalHandler, 750);
}
function DestroyDirectionDetection(hostElement) {
    if (hostElement && hostElement['rtlInterval']) {
        clearInterval(hostElement['rtlInterval']);
    }
}

function setDesignVersion() {
    const frameworkVersion = getComputedStyle(document.documentElement).getPropertyValue('--cwc-version');
    return frameworkVersion ? frameworkVersion : 'v1';
}

function initBasics(componentClass) {
    !componentClass.designVersion && (componentClass.designVersion = setDesignVersion());
    if (!componentClass.rtl) {
        componentClass.host && InitializeDirectionDetection(componentClass.host);
    }
}
function destroyBasics(componentClass) {
    DestroyDirectionDetection(componentClass.host);
}




/***/ }),

/***/ 34194:
/*!****************************************************************************!*\
  !*** ./node_modules/@cmx-web-components/core/dist/esm/cwc-select.entry.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cwc_select": () => (/* binding */ Select)
/* harmony export */ });
/* harmony import */ var D_Documentos_Documentos_DocumentosPersonales_Cemex_ApkMovilCEMEX_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core-cf426fab.js */ 98545);
/* harmony import */ var _commonComponentFeatures_b771e888_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commonComponentFeatures-b771e888.js */ 27345);



const Select = class {
  constructor(hostRef) {
    (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.r)(this, hostRef);
    /**
     * The CwcSelectOption tags nested in this component
     */

    this.allDropdownOptions = [];
    /**
     * The design version of the framework
     */

    this.designVersion = null;
    /**
     * Enables debug logging via console.info
     */

    this.debug = false;
    /** Defines max height in px of the select dropdown */

    this.dropdownMaxHeight = null;
    /**
     * Input label
     */

    this.label = '';
    /**
     * Status of the form field.
     */

    this.status = 'regular';
    /**
     * Defines if the options will be multiple (with checkbox)
     */

    this.multiple = false;
    /**
     * Allows unselection of single option
     */

    this.allowUnselection = false;
    /**
     * When set to true, loader will appear inside the input
     */

    this.loading = false;
    /**
     * When set to true, dropdown will show options filter input
     */

    this.filter = false;
    /**
     * Value of the filter input
     */

    this.filterValue = null;
    /**
     * Placeholder for options filter input
     */

    this.filterPlaceholder = 'Filter Options';
    /**
     * Debounce time applied on options filter input (in milliseconds)
     */

    this.filterDebounceTime = 0;
    /**
     * Text displayed when options filter has no results
     */

    this.filterNoResultsMessage = 'No results';
    /**
     * Defines whether on multiple option should show option "Select All"
     */

    this.selectAll = false;
    /**
     * Select all checkbox label
     */

    this.selectAllLabel = 'Select all';
    /**
     * Sets component as disabled
     */

    this.disabled = false;
    /**
     * Sets trailing icon of dropdown
     */

    this.trailingIcon = 'down-single';
    /**
     * Specify whether component should render from right to left
     */

    this.rtl = false;
    /**
     * When set to true the element is required and the label is decorated with an asterisk (*)
     */

    this.required = false;
    /**
     * When set to true the component doesn't render form-group wrapper
     */

    this.unwrap = false;
    /**
     * Specify if input label should render for mobile
     */

    this.mobile = false;
    /**
     * This property sets the appearance variation of the select.
     */

    this.variant = 'regular';
    /**
     * Specify the width of the layer in CSS units
     */

    this.width = 'auto';
    /**
     * Specify the minWidth of the layer in CSS units
     */

    this.minWidth = '100px';
    /**
     * Specify the height of the layer in CSS units
     */

    this.height = 'auto';
    /**
     * Value of the selected option(s)
     */

    this.controlValue = null;
    /**
     * Shows the dropdown options list
     */

    this.showDropdown = false;
    /**
     * Currently selected options
     */

    this.selectedOptions = [];
    /**
     * Defines whether the filter result is empty
     */

    this.emptyFilter = false;
    /**
     * Shows footer when set to true
     * Footer is added through slot named 'footer'
     */

    this.showFooter = false;
    /**
     * Value displayed in dropdown input
     */

    this.labelValue = '';

    this.onBlur = ev => {
      ev.stopPropagation();
      window.removeEventListener('keydown', this.handleKeystrokes);
      this.cwcBlur.emit();
    };

    this.onFocus = ev => {
      ev.stopPropagation();
      window.addEventListener('keydown', this.handleKeystrokes);
      this.cwcFocus.emit();
    };

    this.closeDropdown = () => {
      if (this.showDropdown) {
        this.showDropdown = false;
        this.trailingIcon = 'down-single';
        this.debug && console.info('closing dropdown');
      }
    };

    this.openDropdown = () => {
      if (!this.showDropdown && !this.disabled && !this.loading) {
        this.showDropdown = true;
        this.trailingIcon = 'up-single';
        this.debug && console.info('opening dropdown');
      }
    };

    this.toggleDropdown = () => {
      if (this.showDropdown) {
        this.closeDropdown();
      } else {
        this.openDropdown();
      }
    }; // returns all options and helpers such as Select All if present


    this.optionsAndHelpers = () => {
      if (this.selectAll) {
        return [...[this.selectAllOptionEl], ...this.allDropdownOptions];
      }

      return this.allDropdownOptions;
    }; // selects/toggles keyboard focused option


    this.selectFocused = () => {
      const optionsToBrowse = this.optionsAndHelpers(); // determine if there's a focused option

      const focusedOption = optionsToBrowse.filter(optionEl => optionEl.focused === true)[0];

      if (focusedOption) {
        if (focusedOption.selected) {
          focusedOption.unselectOption();
        } else {
          focusedOption.selectOption();
        }

        if (!this.multiple) {
          this.closeDropdown();
        }
      }
    }; // this function we use to navigate the options list with arrows up and down.


    this.navigateList = (down = true) => {
      // if the list is closed, let's open it
      this.openDropdown(); // lets browse options and select all if present

      const optionsToBrowse = this.optionsAndHelpers(); // determine if there's a focused option

      const focusedOption = optionsToBrowse.filter(optionEl => optionEl.focused === true)[0];
      let nextOption;
      const resetIndex = down ? 0 : optionsToBrowse.length - 1;

      if (focusedOption) {
        // we remove the focus from ye olde option
        focusedOption.focused = false; // we move next or rev depending on the down mode
        // check the index of next/prev option

        const nextOptionIndex = optionsToBrowse.indexOf(focusedOption) + (down ? 1 : -1);
        nextOption = optionsToBrowse[nextOptionIndex];

        if (!nextOption) {
          // if next sibling element is null, then we are at the end/top of the list, so we reset
          nextOption = optionsToBrowse[resetIndex];
        }
      } else {
        // if tnothing's focused we start from the reset point as well
        nextOption = optionsToBrowse[resetIndex];
      } // we set property focused as true


      nextOption.focused = true; // we scroll the option into view if it's not.

      nextOption.scrollIntoView(false);
    };

    this.handleKeystrokes = e => {
      // get the pressed key
      const key = e.code; // we let tab get used normally to advance back and forth in the tabindex

      if (key !== 'Tab') {
        // if not tab, let's prevent default behavior to act upon the keystroke
        e.preventDefault(); // get the adequate funciton for each keystroke

        const keyFn = this.getKeystrokeFunction(key); // if there's a function

        if (keyFn) {
          // execute
          keyFn(e);
        } // add support for filtering keydown implementation here on else

      }
    };

    this.cwcChange = (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "cwcChange", 7);
    this.cwcFilter = (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "cwcFilter", 7);
    this.cwcBlur = (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "cwcBlur", 7);
    this.cwcFocus = (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, "cwcFocus", 7);
  }

  setSelections(newValues, oldValues) {
    if (newValues !== oldValues) {
      this.checkSelectValue(newValues, false);
    }
  }

  changeMultiple(isMultiple) {
    if (isMultiple) {
      this.allDropdownOptions.forEach(option => option.setOptionAsMultiple());
    } else {
      this.allDropdownOptions.forEach(option => {
        option.setOptionAsSimple();
        option.unselectOption();
      });
      this.selectedOptions = [];
      this.reflectSelectedOptionsToComponent();
    }
  }

  changeAllowUnselection(allowUnselection) {
    this.allDropdownOptions.forEach(option => option.allowUnselection = allowUnselection);
  }

  filterValueChanged(newValue) {
    this.filterOptions(newValue);
  }

  changeSelectAll(selectAll) {
    if (selectAll) {
      this.registerSelectAllOption();
    } else {
      this.selectAllOptionEl = undefined;
    }
  }

  changeRtl(isRtl) {
    this.allDropdownOptions.forEach(option => option.rtl = isRtl);
    this.setSelectAllOptionElementDirection();
  }

  changeVariant(newVariant, oldVariant) {
    if (newVariant !== oldVariant) {
      this.reflectSelectedOptionsToComponent();
    }
  }
  /**
   * Triggered when option is selected. Event emitted in cwc-select-option
   * @param event Event details
   */


  optionSelectedHandler(event) {
    event.stopPropagation();
    const optionsToBrowse = this.optionsAndHelpers();
    const newSelectedOption = optionsToBrowse.filter(optionEl => optionEl.value === event.detail.value)[0];

    if (this.multiple) {
      this.selectNewMultipleOption(event.detail);
    } else if (newSelectedOption) {
      this.selectNewSimpleOption(newSelectedOption, event.detail, !event.detail.selectedByProp);
    }

    this.updateTextInTheComponent(!event.detail.selectedByProp);
  }
  /**
   * Listens to click outside the component and hides the dropdown options list if is currently shown
   * @param event Event Details
   */


  handleClick(event) {
    if (this.showDropdown && !this.host.contains(event.target)) {
      this.closeDropdown();
    }
  }
  /**
   * Register option when it is hits the DOM.
   * @param element The option element
   */


  registerOption(element) {
    var _this = this;

    return (0,D_Documentos_Documentos_DocumentosPersonales_Cemex_ApkMovilCEMEX_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this.allDropdownOptions.push(element);

      _this.sortSelectOptions();

      _this.checkPreselectedOptions();

      _this.registerLabelFocusHandler();

      _this.registerSelectAllOption();

      _this.checkFooterSlot();

      _this.checkSelectValue(_this.value, false);

      _this.filterOptions(_this.filterValue); // if all options are selected, then selecct the select-all option as well
      // setTimeout is needed to target the select-all checkbox correctly


      setTimeout(() => _this.handleSelectAllCheckbox(), 1);
    })();
  }
  /**
   * Unregister option when it is removed from the DOM
   * @param element The option element
   */


  unregisterOption(element) {
    var _this2 = this;

    return (0,D_Documentos_Documentos_DocumentosPersonales_Cemex_ApkMovilCEMEX_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this2.allDropdownOptions = _this2.allDropdownOptions.filter(optionEl => optionEl !== element);
      _this2.selectedOptions = _this2.selectedOptions.filter(optionEl => optionEl.value !== element.value);

      _this2.updateTextInTheComponent(false);
    })();
  }
  /**
   * Set component value and emit cwcChange event. This is handy for emulating user input in automated testing tools.
   * @param value New value
   */


  writeValue(value) {
    var _this3 = this;

    return (0,D_Documentos_Documentos_DocumentosPersonales_Cemex_ApkMovilCEMEX_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this3.checkSelectValue(value, true);
    })();
  }

  componentWillLoad() {
    (0,_commonComponentFeatures_b771e888_js__WEBPACK_IMPORTED_MODULE_2__.i)(this);
  }

  disconnectedCallback() {
    (0,_commonComponentFeatures_b771e888_js__WEBPACK_IMPORTED_MODULE_2__.d)(this);
  }
  /**
   * Lifecycle hook - componentDidLoad
   */


  componentDidLoad() {
    this.setSelectAllOptionElementDirection();
  }

  setSelectAllOptionElementDirection() {
    if (this.selectAllOptionEl) {
      this.selectAllOptionEl.rtl = this.rtl;
    }
  }

  registerLabelFocusHandler() {
    const selectInputEl = this.host.shadowRoot.querySelector('.cwc-select-control');
    selectInputEl.addEventListener('focus', () => {// this.onDropdownClick();
    }, true);
  }

  registerSelectAllOption() {
    if (this.selectAll && this.selectAllOptionEl) {
      this.selectAllOptionEl.setOptionAsMultiple();
    }
  }

  checkFooterSlot() {
    const footerEl = this.host.querySelector('[slot="footer"]');

    if (footerEl && footerEl.innerHTML) {
      this.showFooter = true;
    }
  }
  /**
   * Creates a SelectedOption object from an option-tag in the DOM.
   * @param theElement an option tag
   */


  getElementAsSelectedOption(theElement) {
    return {
      name: theElement.textContent,
      value: theElement.value
    };
  }
  /**
   * Select 'Select all' button if all options selected or unselect if not.
   */


  handleSelectAllCheckbox() {
    if (this.multiple && this.selectAll) {
      const selectAllCheckbox = this.selectAllOptionEl.shadowRoot.querySelector('cwc-checkbox');
      const allDropDownsLength = this.getAllActiveDropDown().length;
      const selectAllCheckboxChecked = this.selectedOptions.length === allDropDownsLength && allDropDownsLength > 0;

      if (selectAllCheckbox) {
        selectAllCheckbox.checked = selectAllCheckboxChecked;
      } // If select-all is checked and select-all-message defined, then display the message in the select input


      if (selectAllCheckboxChecked && this.selectAllMessage) {
        this.setComponentTextValue(this.selectAllMessage);
      }
    }
  }
  /**
   * Updates the text-box with the current selections and if set to true, emits a change-event with the
   * new state.
   */


  updateTextInTheComponent(emitEvent = true) {
    this.reflectSelectedOptionsToComponent();
    this.handleSelectAllCheckbox();

    if (emitEvent) {
      if (this.controlValue) {
        if (Array.isArray(this.controlValue)) {
          this.controlValue.forEach(value => delete value['selectedByProp']);
        } else {
          delete this.controlValue['selectedByProp'];
        }
      }

      this.debug && console.info('emitting cwcChange event', this.controlValue);
      this.cwcChange.emit(this.controlValue);
    }
  }
  /**
   * Whether a value has a matching cwc-option tag in this select.
   * @param lookingFor a value to look for in the options for this select.
   */


  canBeFoundInTheOptions(lookingFor) {
    return this.allDropdownOptions.findIndex(optionEl => optionEl.value === lookingFor.toString()) !== -1;
  }

  sortSelectOptions() {
    const optionsFromUI = Array.from(this.host.getElementsByTagName('cwc-select-option'));
    this.allDropdownOptions.forEach(option => {
      option['position'] = optionsFromUI.indexOf(option);
    });
    this.allDropdownOptions.sort((a, b) => a['position'] - b['position']);
  }
  /**
   * Updates the text which shows the current selection from the options.
   */


  reflectSelectedOptionsToComponent() {
    if (this.selectedOptions.length) {
      const joinedNames = this.selectedOptions.map(option => option.name).join(', ');
      this.setComponentTextValue(joinedNames);
    } else {
      this.setComponentTextValue(null);
    } // when selectedOptions is an empty array, return null
    // otherwise return array or object


    this.controlValue = Array.isArray(this.selectedOptions) && this.selectedOptions.length === 0 ? null : this.multiple ? [...this.selectedOptions] : Object.assign({}, this.selectedOptions[0]);
  }

  setComponentTextValue(textValue) {
    if (this.variant === 'no-border') {
      this.labelValue = textValue && textValue.length > 1 ? textValue : this.placeholder;
    } else {
      this.labelValue = textValue;
      this.host.shadowRoot.querySelector('.cwc-select-control').value = textValue;
    }
  }

  selectNewSimpleOption(newSelectedOption, newOption, emitEvent) {
    const isAlreadySelected = this.selectedOptions.some(option => option.value === newOption.value);

    if (isAlreadySelected || this.multiple && this.selectedOptions.length === 0 && emitEvent) {
      newSelectedOption.unselectOption();
      this.selectedOptions = [];
      this.debug && console.info(`unselecting single option ${newSelectedOption.value}`);
    } else if (newSelectedOption.selected) {
      this.unselectAllOtherSelectedOptions(newSelectedOption);
      this.selectedOptions[0] = newOption;
      this.debug && console.info(`unselecting all single options but ${newSelectedOption.value}`);
    }

    this.closeDropdown();
  }

  selectNewMultipleOption(newOption) {
    const isAlreadySelected = this.selectedOptions.some(option => option.value === newOption.value);

    if (isAlreadySelected) {
      this.selectedOptions = this.selectedOptions.filter(option => option.value !== newOption.value);
      this.debug && console.info(`unselecting multiple option ${newOption.value}`);
    } else {
      this.selectedOptions.push(newOption);
      this.debug && console.info(`selecting multiple option ${newOption.value}`);
    }
  }

  unselectAllSelectedOptions(disableEmitEvent = true) {
    this.allDropdownOptions.filter(optionEl => optionEl.selected === true).forEach(optionEl => {
      if (!optionEl.disabled) {
        optionEl.unselectOption(disableEmitEvent);
      }
    });
    this.selectedOptions = [];
  }

  unselectAllOtherSelectedOptions(exceptionOption) {
    this.allDropdownOptions.filter(optionEl => optionEl !== exceptionOption && optionEl.selected).map(optionEl => optionEl.unselectOption(true));
  }

  checkPreselectedOptions() {
    const selectedOptions = this.allDropdownOptions.filter(optionEl => optionEl['selected'] || false);

    if (selectedOptions) {
      this.selectedOptions = Array.from(selectedOptions).map(selectedOption => this.getElementAsSelectedOption(selectedOption));
    }

    this.reflectSelectedOptionsToComponent();
  }
  /**
   * In case select have predefined value, this will be reflected to the component and options
   */


  checkSelectValue(value, emitEvent = true) {
    if (typeof value === 'undefined') {
      return;
    } // Reset the select when the value is null


    if (value === null) {
      this.unselectAllSelectedOptions(true);
      this.updateTextInTheComponent(emitEvent);
      return;
    }

    const workingValues = value['every'] ? value : [value]; // We only want to update if all the selected values fall within
    // the set of the existing drop-down options.  Otherwise, do nothing
    // because the action is to select a non-existent item

    if (workingValues && workingValues.every(this.canBeFoundInTheOptions, this)) {
      // Set the active options based on the new value array
      this.unselectAllSelectedOptions();

      if (this.multiple) {
        this.allDropdownOptions.filter(optionEl => workingValues.includes(optionEl.value) && (!optionEl.disabled || optionEl.selected)).forEach(optionEl => {
          this.addOptionToSelectedOptions(optionEl);
        });
      } else {
        // This is a single select.  I don't care how any items you put into the value property,
        // or how many matches there might be.  You're getting the first one of each and that's it.
        const yourChoice = this.allDropdownOptions.filter(justOne => justOne.value === workingValues[0])[0];

        if (yourChoice !== undefined) {
          this.addOptionToSelectedOptions(yourChoice);
        }
      }

      this.updateTextInTheComponent(emitEvent);
    }
  }

  addOptionToSelectedOptions(option, disableEmit = true) {
    option.selectOption(disableEmit);
    this.selectedOptions.push({
      name: option.textContent,
      value: option.value
    });
  }

  onFilterValueChange(event) {
    event.stopPropagation();
    this.cwcFilter.emit(event.detail);
    this.filterValue = event.detail;
  }

  filterOptions(query) {
    if (!this.filter) return;
    const lcQuery = query === null ? '' : query.toLowerCase();
    const optionsToShow = this.allDropdownOptions.filter(optionElShow => optionElShow.textContent.toLowerCase().indexOf(lcQuery) > -1); // Hide all options

    this.allDropdownOptions.forEach(optionEl => {
      optionEl.hideOption();
    }); // Show the options that meet the filter query criteria and highlight the filter characters in the options

    optionsToShow.forEach(optionEl => {
      optionEl.showOption();
      optionEl.highlightText(lcQuery);
    }); // Show 'No results' label

    this.emptyFilter = optionsToShow.length === 0;
  }
  /**
   * Return all active dropdown
   */


  getAllActiveDropDown() {
    return this.allDropdownOptions.filter(dropDown => !dropDown.disabled);
  }
  /**
   * Return true if all drop down selected
   */


  isSelectedAllDropDown() {
    const allDropDownsLength = this.getAllActiveDropDown().length;
    return this.selectedOptions.length === allDropDownsLength && allDropDownsLength > 0;
  }

  onSelectAllChange(event) {
    event.stopPropagation();
    const ifAllSelected = this.isSelectedAllDropDown();

    if ((this.selectAllOptionEl.selected || !ifAllSelected) && !(this.selectAllOptionEl.selected && ifAllSelected)) {
      // Select All
      this.unselectAllSelectedOptions();
      this.allDropdownOptions.forEach(optionEl => {
        if (!optionEl.disabled || optionEl.selected) {
          optionEl.selectOption(true);
          this.selectedOptions.push({
            name: optionEl.textContent,
            value: optionEl.value
          });
        }
      });
    } else {
      this.unselectAllSelectedOptions();
    }

    this.updateTextInTheComponent();
  }

  getKeystrokeFunction(key) {
    const keys = new Map();
    keys.set('ArrowDown', () => {
      this.navigateList(true);
    });
    keys.set('ArrowUp', () => {
      this.navigateList(false);
    });
    keys.set('Escape', () => {
      this.closeDropdown();
    });
    keys.set('Space', () => {
      if (!this.showDropdown) {
        this.openDropdown();
      } else {
        this.selectFocused();
      }
    });
    keys.set('Enter', () => {
      if (!this.showDropdown) {
        this.openDropdown();
      } else {
        this.selectFocused();
      }
    });
    return keys.get(key);
  }

  render() {
    // the filter to narrow down the options within the select
    const optionsFilter = this.filter && (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "cwc-select-dd__filter"
    }, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("cwc-input", {
      "leading-icon": "magnifier-glass",
      placeholder: this.filterPlaceholder,
      "debounce-time": this.filterDebounceTime,
      value: this.filterValue,
      variant: "single-line",
      onCwcChange: event => this.onFilterValueChange(event),
      style: {
        width: '100%'
      },
      nativeElementTabIndex: "-1",
      unwrap: true,
      mobile: this.mobile,
      designVersion: this.designVersion
    })); // when there's multiple selection there might be the possibility of selecting all options

    const optionsSelectAll = this.selectAll && (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("cwc-select-option", {
      ref: el => this.selectAllOptionEl = el,
      value: "cwc_select_all_value",
      onCwcSelectOptionSelected: event => this.onSelectAllChange(event),
      designVersion: this.designVersion
    }, this.selectAllLabel); // the actual options

    const options = (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "cwc-select__options",
      role: "listbox"
    }, this.emptyFilter && (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
      class: "no-results"
    }, this.filterNoResultsMessage), optionsSelectAll, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", null)); // the footer of the options

    const optionsFooter = this.showFooter && (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "cwc-select-dd__footer"
    }, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "footer"
    })); // the dropdown layer of the select

    const selectLayer = (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      slot: "content",
      class: 'cwc-select-dd' + (this.unwrap ? ' cwc-select-dd--unwrapped' : '') + (this.variant === 'no-border' ? ' cwc-select-dd--no-border' : ''),
      style: {
        maxHeight: this.dropdownMaxHeight ? this.dropdownMaxHeight + `px` : 'auto'
      }
    }, optionsFilter, options, optionsFooter); // the select's clickable portion

    const selectTarget = this.variant === 'regular' ? (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("cwc-input", {
      label: this.label,
      required: this.required,
      value: this.labelValue,
      onCwcChange: event => event.stopPropagation(),
      "trailing-icon": this.trailingIcon,
      placeholder: this.placeholder,
      disabled: this.disabled,
      status: this.status,
      statusMessage: this.statusMessage,
      loading: this.loading,
      class: "cwc-select-control",
      unwrap: true,
      variant: "select-box",
      slot: "target",
      style: {
        width: '100%'
      },
      onCwcFocus: this.onFocus,
      onCwcBlur: this.onBlur,
      onClick: this.toggleDropdown,
      readonly: true,
      mobile: this.mobile,
      designVersion: this.designVersion
    }) : this.variant === 'header' ? (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
      slot: "target",
      class: 'cwc-select-control cwc-select-control--header ' + (this.disabled ? ' disabled' : ''),
      onClick: this.toggleDropdown
    }, this.label) : (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
      slot: "target",
      class: 'cwc-select-control cwc-select-control--no-border ' + (this.disabled ? ' disabled' : ''),
      onClick: this.toggleDropdown
    }, this.labelValue); // all selects use overlay, so this is a must

    const overlayComponent = (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("cwc-overlay", {
      disabled: this.disabled,
      noToggle: true,
      height: this.height,
      width: this.width,
      minWidth: this.minWidth,
      show: this.showDropdown,
      style: this.variant === 'no-border' && this.unwrap ? {
        maxHeight: '1rem'
      } : {},
      block: true,
      designVersion: this.designVersion
    }, selectTarget, selectLayer); // here we determine if the select wrapper is going to be a plain div
    // or the form group (label, error, etc) depending on the unwrap parameter

    const selectContents = this.unwrap ? (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", null, overlayComponent) : (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("cwc-form-group", {
      label: this.label,
      required: this.required,
      status: this.status,
      statusMessage: this.statusMessage,
      slot: "target",
      mobile: this.mobile,
      designVersion: this.designVersion
    }, overlayComponent); // return the select structure

    return (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)(_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.H, null, (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: `cwc-select ${this.designVersion}`
    }, selectContents));
  }

  get host() {
    return (0,_core_cf426fab_js__WEBPACK_IMPORTED_MODULE_1__.g)(this);
  }

  static get watchers() {
    return {
      "value": ["setSelections"],
      "multiple": ["changeMultiple"],
      "allowUnselection": ["changeAllowUnselection"],
      "filterValue": ["filterValueChanged"],
      "selectAll": ["changeSelectAll"],
      "rtl": ["changeRtl"],
      "variant": ["changeVariant"]
    };
  }

  static get style() {
    return "\@charset \"UTF-8\";*{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:host{display:inline-block}::-webkit-scrollbar{width:16px}::-webkit-scrollbar-track{background:transparent}::-webkit-scrollbar-thumb{background-image:url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDRhNCA0IDAgMSAxIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii40Ii8+PC9zdmc+\"),url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDBhNCA0IDAgMSAwIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii40Ii8+PC9zdmc+\"),url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0wIDBoOHY4SDB6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iLjQiLz48L3N2Zz4=\");background-repeat:no-repeat,no-repeat,no-repeat;background-position:top,bottom,50%;background-size:auto,auto,8px calc(100% - 8px)}::-webkit-scrollbar-thumb:hover{background-image:url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDRhNCA0IDAgMSAxIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii42Ii8+PC9zdmc+\"),url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0wIDBhNCA0IDAgMSAwIDggMEgweiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBmaWxsLW9wYWNpdHk9Ii42Ii8+PC9zdmc+\"),url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOCIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0wIDBoOHY4SDB6IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGZpbGwtb3BhY2l0eT0iLjYiLz48L3N2Zz4=\")}.cwc-select{position:relative}.cwc-select>cwc-form-group,.cwc-select>cwc-form-group cwc-overlay{width:100%}.cwc-select>cwc-form-group cwc-overlay>cwc-input{display:block!important;width:100%}.cwc-select-control--header,.cwc-select-control--no-border{position:relative;display:inline-block;padding-right:1.5rem;cursor:pointer;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;max-width:100%;white-space:nowrap;line-height:1rem}.cwc-select-control--header.disabled,.cwc-select-control--no-border.disabled{cursor:default;color:var(--cwc-select-disabled-color,var(--cwc-color-elements-input-border,#adaebb))}.cwc-select-control--header.disabled:after,.cwc-select-control--header.disabled:before,.cwc-select-control--no-border.disabled:after,.cwc-select-control--no-border.disabled:before{color:var(--cwc-select-disabled-after-color,var(--cwc-color-elements-input-border,#adaebb))}.cwc-select-control--header:after,.cwc-select-control--no-border:after{font-family:dls-icons!important;content:\"\";color:var(--cwc-select-icon-color,var(--cwc-color-links,#3fa9f5));position:absolute;right:0;top:0}.cwc-select-dd{display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;height:100%;font-weight:400}.cwc-select-dd--no-border,.cwc-select-dd--unwrapped{margin-top:0}.cwc-select-dd.hidden{opacity:0;pointer-events:none}.cwc-select-dd__filter{background:var(--cwc-select-filter-background,var(--cwc-color-grayscale-white,#fff));margin:0 1rem;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex:0 0 auto;flex:0 0 auto;width:calc(100% - 2rem);z-index:1}.cwc-select-dd__filter>*{width:100%}.cwc-select-dd__filter+.cwc-select__options .cwc-select__option:first-child{margin-top:0}.cwc-select-dd__filter-icon{color:var(--cwc-select-filter-icon-color,var(--cwc-color-links,#3fa9f5));padding-top:2px}.cwc-select-dd__footer{background:var(--cwc-select-footer-background,var(--cwc-color-grayscale-white,#fff));display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex:0 0 auto;flex:0 0 auto;position:relative;width:calc(100% - 2rem);z-index:1;bottom:0;border-top:.0625rem solid var(--cwc-select-footer-border-top,var(--cwc-color-elements-input-border,#adaebb));margin:0 1rem}.cwc-select-dd.filtered .cwc-select-dd__option.check-all{display:none}.cwc-select-dd .no-results{margin:0 1rem;display:block;color:var(--cwc-select-no-result-color,var(--cwc-color-grayscale-medium,#666));padding:.5rem 0}.cwc-select__options{overflow:auto;-ms-flex:1 1 auto;flex:1 1 auto}.cwc-select__options>slot{display:block}.cwc-select__select-all{padding:.25rem 0 0!important}.cwc-select__select-all:after{content:\" \";display:block;margin:0 1rem;height:0;border-bottom:1px solid var(--cwc-select-select-all-border-bottom,var(--cwc-color-elements-input-border,#adaebb))}[dir=rtl] .cwc-select-control--no-border{padding-right:0;padding-left:1.5rem}[dir=rtl] .cwc-select-control--no-border:after{right:auto;left:0}";
  }

};


/***/ })

}]);
//# sourceMappingURL=node_modules_cmx-web-components_core_dist_esm_cwc-select_entry_js.js.map